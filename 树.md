# 树

![1572613191624](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572613191624.png)

![1572613218572](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572613218572.png)

## 二叉树

**简介**

二叉树是指每个最多包含一个左子节点和一个右子节点的树

**图解**

![1572613244952](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572613244952.png)

### 二叉树的遍历

分为三种：前序中序后序，根据遍历根节点的次序分为这三种遍历

**图解**

![1572613291620](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572613291620.png)

**查找**

查找与遍历一样。可以通过三种遍历进行查找只不过遍历只是输出而查找在每次遍历一个节点就左判断有符合的则结束返回没有则继续递归查找若找完还未找到则返回null

**图解**

![1572613425572](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572613425572.png)

**删除**

这里是简单删除，先遍历查找到要删除的节点，然后将整个子树删除不考虑其他情况

**图解**

![1572613486244](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572613486244.png)



**代码**

```java
package priv.wzb.datastructure.tree;

/**
 * @author Satsuki
 * @time 2019/11/1 17:20
 * @description:
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "无用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");

        // 先手动创建，后面再递归
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);
        // pre:12354,infix:21534,post:25431

        // 测试
        System.out.println("前序：");
        binaryTree.preOrder();
        System.out.println("infix：");
        binaryTree.infixOrder();
        System.out.println("post：");
        binaryTree.postOrder();

        HeroNode node;
        System.out.println("查找");
        System.out.println("preOrderSearch");
        node = binaryTree.preOrderSearch(5);
        if (node!=null){
            System.out.println(node.toString());
        }
        System.out.println("infixOrderSearch");
        node = binaryTree.infixOrderSearch(5);
        if (node!=null){
            System.out.println(node.toString());
        }
        System.out.println("postOrderSearch");
        node = binaryTree.postOrderSearch(5);
        if (node!=null){
            System.out.println(node.toString());
        }

        System.out.println("删除节点");
        System.out.println("before del");
        binaryTree.preOrder();
//        binaryTree.delNode(5);
        binaryTree.delNode(3);
        System.out.println("after del");
        binaryTree.preOrder();
    }
}

// 定义一颗二叉树
class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 前序
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    // 中序
    public void infixOrder(){
        if (this.root!=null){
            this.root.infixOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    // 后序
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    public HeroNode preOrderSearch(int no){
        if (root != null){
            return root.preOrderSearch(no);
        }
        return null;
    }
    public HeroNode infixOrderSearch(int no){
        if (root != null){
            return root.infixOrderSearch(no);
        }
        return null;
    }
    public HeroNode postOrderSearch(int no){
        if (root != null){
            return root.postOrderSearch(no);
        }
        return null;
    }

    public void delNode(int no){
        if (root!=null){
            if (root.getNo() == no){
                root =null;
            }else {
                root.delNode(no);
            }

        }else {
            System.out.println("null tree can't del");
        }
    }
}

// 先创建HeroNode节点
// 数节点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    // 编写遍历
    // 前序（根左右）
    public void preOrder(){
        System.out.println(this.toString());

        if (this.left!=null){
            // 左子树不为空
            // 遍历左子树
            this.left.preOrder();
        }
        if (this.right!=null){
            // 右子树不为空
            // 遍历右子树
            this.right.preOrder();
        }
    }
    // 中序（左根右）
    public void infixOrder(){
        if (this.left!=null){
            // 左子树不为空
            // 遍历左子树
            this.left.infixOrder();
        }

        System.out.println(this.toString());

        if (this.right!=null){
            // 右子树不为空
            // 遍历右子树
            this.right.infixOrder();
        }
    }
    // 后序（左右根）
    public void postOrder(){

        if (this.left!=null){
            // 左子树不为空
            // 遍历左子树
            this.left.postOrder();
        }
        if (this.right!=null){
            // 右子树不为空
            // 遍历右子树
            this.right.postOrder();
        }
        System.out.println(this.toString());
    }



    public HeroNode preOrderSearch(int no){
        // 这里才是真正比较的地方
        System.out.println("pre count");
        if (this.no == no){
            return this;
        }

        HeroNode resNode = null;
        if (this.left!=null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.right!=null){
            resNode = this.right.preOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        return resNode;
    }

    public HeroNode infixOrderSearch(int no){



        HeroNode resNode = null;
        if (this.left!=null){
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }

        System.out.println("infix count");
        if (this.no == no){
            return this;
        }

        if (this.right!=null){
            resNode = this.right.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        return resNode;
    }

    public HeroNode postOrderSearch(int no){


        HeroNode resNode = null;
        if (this.left!=null){
            resNode = this.left.postOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.right!=null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }

        System.out.println("post count");
        if (this.no == no){
            return this;
        }
        return resNode;
    }

    public void delNode(int no){
        System.out.println("delno=" + no);
        if (this.left!=null && this.left.no == no){
            this.left = null;
            return;
        }
        if (this.right!=null && this.right.no == no){
            this.right = null;
            return;
        }

        if (this.left!=null){
           this.left.delNode(no);
        }

        if (this.right!=null){
            this.right.delNode(no);
        }

    }

}
```

## 顺序存储二叉树

**概念**

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，

**图解**

![1572703484553](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572703484553.png)

图中二叉树的节点要求以数组的方式来存放arr:[1,2,3,4,5,6,7]

在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成节点的遍历

**特点**

- 顺序二叉树通常只考虑完全二叉树
- 第n个元素的左子节点为2*1+1
- 第n个元素的右子节点为2*1+2
- 第n个元素的父节点为（n-1)/2
- n:表示二叉树中的第n个元素（从0开始



**代码**

```java
package priv.wzb.datastructure.tree;

/**
 * @author Satsuki
 * @time 2019/11/2 15:35
 * @description:
 */
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
//        int[] arr = {1,2,3,4,5,6,7};
        int[] arr = {1,3,6,8,10,14};
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
//        arrBinaryTree.preOrder(0);
//        arrBinaryTree.preOrder();
        arrBinaryTree.infixOrder(0);
//        arrBinaryTree.postOrder(0);

    }
}

// 编写一个ArrayBinaryTree,实现顺序存储二叉树遍历
class ArrBinaryTree{
    // 存储数据节点的数组
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    // 重载preOrder
    public void preOrder(){
        this.preOrder(0);
    }
    // 编写一个方法，完成顺序存储二叉树的前序遍历

    /**
     *
     * @param index 数组的下标
     */
    public void preOrder(int index){
        // 如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能进行前序遍历");
        }
        // 输出当前这个元素
        System.out.println(arr[index]);
        // 向左递归遍历
        if (2*index+1<arr.length){
            // 提前判断
            preOrder(2*index+1);
        }
        // 向右递归
        if (index * 2 + 2<arr.length){
            // 判断不越界
            preOrder(index * 2 + 2);
        }
    }

    public void infixOrder(int index){
        // 如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能进行前序遍历");
        }

        // 向左递归遍历
        if (2*index+1<arr.length){
            // 提前判断
            infixOrder(2*index+1);
        }
        // 输出当前这个元素
        System.out.println(arr[index]);
        // 向右递归
        if (index * 2 + 2<arr.length){
            // 判断不越界
            infixOrder(index * 2 + 2);
        }
    }

    public void postOrder(int index){
        // 如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能进行前序遍历");
        }

        // 向左递归遍历
        if (2*index+1<arr.length){
            // 提前判断
            postOrder(2*index+1);
        }
        // 向右递归
        if (index * 2 + 2<arr.length){
            // 判断不越界
            postOrder(index * 2 + 2);
        }
        // 输出当前这个元素
        System.out.println(arr[index]);
    }
}
```



## 线索化二叉树

**概念**

![1572703803481](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572703803481.png)

对上面的二叉树进行中序遍历时数列为{8，3，10，1，6，14}

但是6，8，10，14这几个节点的左右指针并没有完全用上，如果我们希望充分利用各个节点的左右指针，让各个节点指向自己在数列中的前后节点可以使用线索二叉树解决



- n个节点的二叉链表中含有【2n-(n-1)=n+1】个空指针域，利用二叉链表的空指针域，存放指向该节点在某种遍历次序下的前驱或后继节点的指针（这种附加的指针称为线索）
- 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded Binary Tree）。根据树性质的不同，线索二叉树可以分为前序线索二叉树，中序线索二叉树，后序线索二叉树。
- 一个节点的前一个节点称为前驱节点
- 一个节点的后一个节点称为后继节点

**图解**

![1572704101322](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572704101322.png)

在代码中我通过添加了leftType和rightType区分该节点的left和right究竟指向的是子节点还是前驱后继节点

**代码**

```java
package priv.wzb.datastructure.tree.threadedbinarytree;

/**
 * @author Satsuki
 * @time 2019/11/2 16:05
 * @description:
 */
// 先创建HeroNode节点
// 数节点
class HeroNode {
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    // 若leftType为0说明指向左子树，若为1表示指向前驱节点
    // 若rightType为0说明指向右子树，若为1表示指向后继节点
    private int leftType;
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    // 编写遍历
    // 前序（根左右）
    public void preOrder(){
        System.out.println(this.toString());

        if (this.left!=null){
            // 左子树不为空
            // 遍历左子树
            this.left.preOrder();
        }
        if (this.right!=null){
            // 右子树不为空
            // 遍历右子树
            this.right.preOrder();
        }
    }
    // 中序（左根右）
    public void infixOrder(){
        if (this.left!=null){
            // 左子树不为空
            // 遍历左子树
            this.left.infixOrder();
        }

        System.out.println(this.toString());

        if (this.right!=null){
            // 右子树不为空
            // 遍历右子树
            this.right.infixOrder();
        }
    }
    // 后序（左右根）
    public void postOrder(){

        if (this.left!=null){
            // 左子树不为空
            // 遍历左子树
            this.left.postOrder();
        }
        if (this.right!=null){
            // 右子树不为空
            // 遍历右子树
            this.right.postOrder();
        }
        System.out.println(this.toString());
    }



    public HeroNode preOrderSearch(int no){
        // 这里才是真正比较的地方
        System.out.println("pre count");
        if (this.no == no){
            return this;
        }

        HeroNode resNode = null;
        if (this.left!=null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.right!=null){
            resNode = this.right.preOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        return resNode;
    }

    public HeroNode infixOrderSearch(int no){



        HeroNode resNode = null;
        if (this.left!=null){
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }

        System.out.println("infix count");
        if (this.no == no){
            return this;
        }

        if (this.right!=null){
            resNode = this.right.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        return resNode;
    }

    public HeroNode postOrderSearch(int no){


        HeroNode resNode = null;
        if (this.left!=null){
            resNode = this.left.postOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.right!=null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }

        System.out.println("post count");
        if (this.no == no){
            return this;
        }
        return resNode;
    }

    public void delNode(int no){
        System.out.println("delno=" + no);
        if (this.left!=null && this.left.no == no){
            this.left = null;
            return;
        }
        if (this.right!=null && this.right.no == no){
            this.right = null;
            return;
        }

        if (this.left!=null){
            this.left.delNode(no);
        }

        if (this.right!=null){
            this.right.delNode(no);
        }

    }

}


/**
 * @author Satsuki
 * @time 2019/11/2 16:09
 * @description:
 */
// 定义一颗二叉树
    // 线索化二叉树
class ThreadedBinaryTree {
    private HeroNode root;

    // 为了实现线索化，需要创建指向当前节点前驱节点的指针
    // 在递归进行线索化时，pre总是保留前一个节点
    private HeroNode pre = null;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 遍历线索化二叉树
    public void threadList(){
        // 定义一个变量，存储当前遍历的节点，从root开始
        HeroNode node = root;
        while (node != null){
            // 循环找到leftType == 1的节点，第一个找到的就应该是8
            // 后面随着遍历而变化
            // 当leftType==1说明该节点是经过线索化的有效节点
            // 因为中序遍历是左根右
            // 所以按照这个顺序向左递归可以达到完全二叉树的最后一层
            // 这一层的节点被线索化了，因此可以遍历输出中序遍历的数组的顺序
            while (node.getLeftType() == 0){
                node = node.getLeft();
            }

            // 打印当前节点
            System.out.println(node);

            // 如果当前节点的右指针指向后继节点就一直输出
            while (node.getRightType() == 1){
                node = node.getRight();
                System.out.println(node);
            }

            // 替换这个遍历的节点
            // 这样做是为了让节点移动
            node = node.getRight();
        }
    }

    public void threadedNodes(){
        this.threadedNodes(root);
    }

    // 编写对二叉树进行中序线索化的方法
    public void threadedNodes(HeroNode node){
        // 如果node== null，不能线索化
        if (node == null){
            return;
        }

        // 线索化左子树
        threadedNodes(node.getLeft());
        // 线索化当前节点（有难度）
        // 处理当前节点的前驱节点
        if ( node.getLeft() == null){
            // 如果当前节点的做指针为空则指向当前节点的前驱节点
            node.setLeft(pre);
            // 修改当前节点的左指针的类型
            // 1代表左指针指向的是前驱节点
            node.setLeftType(1);
        }

        // 处理后继节点
        // 处理后继节点是放在了下一次递归所以要用前驱节点来做
        if (pre != null && pre.getRight() == null){
            // 让前驱节点的右指针指向当前节点
            pre.setRight(node);
            pre.setRightType(1);
        }
        // ！！！记录当前节点作为下一个节点的前驱节点
        pre = node;
        // 线索化右子树
        threadedNodes(node.getRight());
    }

    // 前序遍历线索化二叉树
    public void preThreadList(){
        // 定义一个变量，存储当前遍历的节点，从root开始
        HeroNode node = root;
        while (node != null){
            // 打印当前节点
//            System.out.println(node);

            // 循环找到leftType == 1的节点，第一个找到的就应该是8
            // 后面随着遍历而变化
            // 当leftType==1说明该节点是经过线索化的有效节点
//            while (node.getLeftType())
//            while (node.getLeftType() == 0){
//                node = node.getLeft();
//            }
            if (node.getLeftType() == 0){
                System.out.println(node);
            }



            // 如果当前节点的右指针指向后继节点就一直输出
            while (node.getRightType() == 1){
                System.out.println(node);
                node = node.getRight();
            }

            // 替换这个遍历的节点
            // 这样做是为了让节点移动
//            node = node.getRight();
            if (node.getLeftType()==0){
                node = node.getLeft();
            }else {
                System.out.println(node);
                break;
            }
        }
    }

    // 编写对二叉树进行前序线索化的方法
    public void preThreadedNodes(HeroNode node){
        // 如果node== null或者已经被线索化了,不能线索化
        if (node == null || node.getLeftType()==1 || node.getRightType()==1){
            return;
        }

//        if (node == null || node.getLeftType()==0 || node.getRightType()==0){
//            return;
//        }


        // 线索化当前节点（有难度）
        // 处理当前节点的前驱节点
        if ( node.getLeft() == null){
            // 如果当前节点的做指针为空则指向当前节点的前驱节点
            node.setLeft(pre);
            // 修改当前节点的左指针的类型
            // 1代表左指针指向的是前驱节点
            node.setLeftType(1);
        }

        // 处理后继节点
        // 处理后继节点是放在了下一次递归所以要用前驱节点来做
        if (pre != null && pre.getRight() == null){
            // 让前驱节点的右指针指向当前节点
            pre.setRight(node);
            pre.setRightType(1);
        }
        // ！！！记录当前节点作为下一个节点的前驱节点
        pre = node;

        // 如果该节点的左子树没被线索化
        // 线索化左子树
        if (node.getLeftType()!=1){
            preThreadedNodes(node.getLeft());
        }

        
        // 如果该节点的右子树没被线索化
        if (node.getRightType()!=1){
            // 线索化右子树
            preThreadedNodes(node.getRight());
        }

    }

    // 前序
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    // 中序
    public void infixOrder(){
        if (this.root!=null){
            this.root.infixOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    // 后序
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    public HeroNode preOrderSearch(int no){
        if (root != null){
            return root.preOrderSearch(no);
        }
        return null;
    }
    public HeroNode infixOrderSearch(int no){
        if (root != null){
            return root.infixOrderSearch(no);
        }
        return null;
    }
    public HeroNode postOrderSearch(int no){
        if (root != null){
            return root.postOrderSearch(no);
        }
        return null;
    }

    public void delNode(int no){
        if (root!=null){
            if (root.getNo() == no){
                root =null;
            }else {
                root.delNode(no);
            }

        }else {
            System.out.println("null tree can't del");
        }
    }
}


/**
 * @author Satsuki
 * @time 2019/11/2 16:03
 * @description:
 */
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        // 测试中序线索二叉树是否正确
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "mary");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        // 简单处理手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);

        node3.setLeft(node6);

        // 测试线索化
        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        // 测试先序
        threadedBinaryTree.preThreadedNodes(root);
//        threadedBinaryTree.threadedNodes();
//
//        // 测试 以10号节点测试
        HeroNode left = node5.getLeft();
        System.out.println("left:" + left);
        HeroNode right = node5.getRight();
        System.out.println("right:" + right);

        // 先序遍历
        threadedBinaryTree.preThreadList();

//        // 线索化遍历
//        System.out.println("线索化遍历");
//        threadedBinaryTree.threadList(); //8,3,10,1,14,6



    }
}




```

上述代码中我完成了前序线索二叉树和中序线索二叉树

## 堆排序

**概念**

- 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最好最坏，平均时间复杂度为O(nlogn)，它也是不稳定排序
- 堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右子节点的值，称为大顶堆，注意：没有要求节点的左孩子的值和右孩子的值的大小关系
- 每个节点的值都小于或等于其左右孩子节点的值称为小顶堆
- 升序一般采用大顶堆，降序一般采用小顶堆

**图解**



![1572704987034](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572704987034.png)

**步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。**

1) .假设给定无序序列结构如下

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps1.jpg) 

2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps2.jpg) 

3) .找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps3.jpg) 

4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps4.jpg) 

此时，我们就将一个无序序列构造成了一个大顶堆。

**步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

1) .将堆顶元素9和末尾元素4进行交换

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps5.jpg) 

2) .重新调整结构，使其继续满足堆定义

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps6.jpg) 

3) .再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps7.jpg) 

4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml8664\wps8.jpg) 

**再简单总结下堆排序的基本思路：**

**1)****.将****无序****序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

　　**2)****.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

　　**3)****.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

 

**代码**

```java
package priv.wzb.datastructure.tree;

import java.util.Arrays;

/**
 * @author Satsuki
 * @time 2019/11/2 18:07
 * @description:
 */
public class HeapSort {
    public static void main(String[] args) {
//        int arr[] = {4,6,8,5,9};
//        // 升序--》大顶堆
//        heapSort(arr);

        long now = System.currentTimeMillis();
        int[] arr = new int[8000000];
        for (int i = 0; i < 8000000; i++) {
            arr[i] = (int)(Math.random() * 80000000);// 生成一个[0,8000000]的随机数
        }
        heapSort(arr);
        long last = System.currentTimeMillis();
        System.out.println("花费时间：" + (last-now));
//        System.out.println(Arrays.toString(arr));
        System.out.println(arr.length);
    }

    // 编写一个堆排序的方法
    public static void heapSort(int arr[]){
        int temp = 0;
        System.out.println("堆排序");
        // 分布完成
        /**
        adjustHeap(arr,1,arr.length);
        System.out.println("first" + Arrays.toString(arr));//4,9,8,5,6

        adjustHeap(arr,0,arr.length);
        System.out.println("sec" + Arrays.toString(arr));//9,6,8,5,1
         **/
        // 最终代码
        // 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
        for (int i = arr.length/2 -1; i >= 0; i--) {
            adjustHeap(arr,i,arr.length);
        }


        // 将堆顶元素与末尾交换，最大元素沉底
        // 重构满足堆定义
        // 反复执行，直到有序
        for (int j = arr.length-1; j > 0; j--) {
            // 交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;

            adjustHeap(arr,0,j);
        }

//        System.out.println("arr=" + Arrays.toString(arr));
    }

    // 将一个数组(二叉树），调整为一个大顶堆

    /**
     *功能：将以i对应的非叶子节点的树调整成大顶堆
     * 举例：int arr[] = {4,6,8,5,9};==> {4,9,8,5,6}
     * @param arr 待调整的数组
     * @param i 非叶子节点在数组中的索引
     * @param length 对多少个元素进行调整，length在逐渐减少
     */
    public static void adjustHeap(int arr[],int i,int length){
        int temp = arr[i]; // 先取出当前元素的值保存在零时变量
        // 开始调整
        //  k = i*2+1 k指向i节点的左子节点
        for (int k = i*2+1; k < length; k=k*2+1) {
            if (k+1<length && arr[k]<arr[k+1]){
                // 左子节点小于右子节点
                k++; // k指向右子节点（较大值）
            }
            if (arr[k]>temp){
                // 如果子节点大于父节点
                // 把较大的值赋给当前节点
                arr[i] = arr[k];
                // i指向k继续循环比较
                i=k;
            }else {
                // 因为这是第一个非叶子节点，从下至上调整所以可以直接break；
                break;
            }
        }

        // 当for循环结束后，我们已经将以i为父节点的树的最大值，放在了最顶（局部）
        arr[i] = temp;


    }
}
```

## Huffman树

**概念**

- 给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree)
- 哈夫曼树是带权路径长度最短的树，权值较大的节点离根较近
- 路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或孙子节点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为L，则从根节点到第L层节点的路径长度为L-1
- 节点的权和带权路径的长度：若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权，节点的带权路径长度为：从根节点到该节点之间的路径长度与改节点的权的乘积
- 树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度即为WPL（weighted path length）,权值越大的节点离根节点越近的二叉树才是最优二叉树



**图解**

![1572705846901](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572705846901.png)

![1572705899916](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572705899916.png)

构成赫夫曼树的步骤：
1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
2) 取出根节点权值最小的两颗二叉树 
3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  
4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

**代码**

```java
package priv.wzb.datastructure.tree.huffmantree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author Satsuki
 * @time 2019/11/2 20:52
 * @description:
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int arr[] = {13,7,8,3,29,6,1};
        Node huffmanTree = createHuffmanTree(arr);

        // 测试
        preOrder(huffmanTree);// 67 29 38 15 7 8 23 10 4 1 3 6 13

    }

    public static void preOrder(Node root){
        if (root != null){
            root.preOrder();
        }else {
            System.out.println("树是空树");
        }
    }

    // 创建huffmanTree
    public static Node createHuffmanTree(int[] arr){
        // 遍历arr数组，构建为Node
        // 放入ArrayList然后进行排序
        List<Node> nodes = new ArrayList<>();
        for(int value : arr){
            nodes.add(new Node(value));
        }

        // 排序
        Collections.sort(nodes);
        System.out.println(nodes);

        while (nodes.size()>1){
            // 取出根节点权值最小的两颗二叉树
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);

            // 构建一颗新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            // 从ArrayList中删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);

            // 添加新的二叉树
            nodes.add(parent);
            Collections.sort(nodes);
            System.out.println("第x步" + nodes);
        }
        // 返回huffmanTree的root节点
        return nodes.get(0);

//        // 取出根节点权值最小的两颗二叉树
//        Node leftNode = nodes.get(0);
//        Node rightNode = nodes.get(1);
//
//        // 构建一颗新的二叉树
//        Node parent = new Node(leftNode.value + rightNode.value);
//        parent.left = leftNode;
//        parent.right = rightNode;
//
//        // 从ArrayList中删除处理过的二叉树
//        nodes.remove(leftNode);
//        nodes.remove(rightNode);
//
//        // 添加新的二叉树
//        nodes.add(parent);
//        Collections.sort(nodes);
//        System.out.println("第一步" + nodes);
    }
}

// 创建节点类
class Node implements Comparable<Node>{
    int value; // 节点权值
    char c;
    Node left; // 指向左子节点
    Node right; // 指向右子节点

    public Node(int value) {
        this.value = value;
    }

    // 前序遍历
    public void preOrder(){
        if (this==null){
            return;
        }
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }

    }

    @Override
    public int compareTo(Node o) {
        return this.value-o.value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```

## Huffman编码

**简介**

- Huffman编码是一种编码方式，属于一种程序算法
- Huffman编码是Huffman树在电讯通信中经典的应用之一
- Huffman编码广泛用于数据文件压缩。其压缩率通常在20%~90%之间
- Huffman编码是可变长编码（VLC）。Huffman在1952年提出的一种编码方法，称之为最佳编码

注意：如果文件本身就是呗压缩处理过的，使用Huffman编码压缩也不会有明显变化例如ppt文件

Huffman编码是按字节来处理的，因此可以处理所有的文件

如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显

**图解**

![1572790906330](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572790906330.png)

![1572790917224](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572790917224.png)

![1572790927960](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572790927960.png)

![1572790942240](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572790942240.png)

![1572790948903](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572790948903.png)

![1572791014264](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572791014264.png)

此编码满足前缀编码，即字符的编码都不是其他字符编码的前缀编码。不会造成匹配的多义性。哈夫曼编码是无损处理方案

![1572791063276](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572791063276.png)



**代码**

**分解**

### 设计节点（在Huffman树节点的基础上添加一些东西

```java
// 创建Node，带数据和权值
class Node implements Comparable<Node>{
    Byte data; // 存放数据本身'a'=>97
    int weight; // 权值，表示字符出现次数
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        // 从小到大排序
        return this.weight-o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }
}
```

### 创建Huffman树

将要进行Huffman编码的字符串转为byte数组（字节数组），将字节数组进行统计转为节点的list集合

```java
/**
 *
 * @param bytes 接收的字符数组
 * @return 返回Node的List
 */
private static List<Node> getNodes(byte[] bytes){
    // 创建一个ArrayList
    List<Node> nodes = new ArrayList<>();

    //遍历bytes，统计每个byte出现的次数。 存储每个byte出现的次数-->map
    HashMap<Byte, Integer> counts = new HashMap<>();
    for(byte b:bytes){
        Integer count = counts.get(b);
        if (count == null){
            // map没有该字符
            // 第一次统计到该字符
            counts.put(b,1);
        }else {
            // 已经保存过该字符，计数
            counts.put(b,count+1);
        }
    }
    // 遍历map把每个entryt转为Node
    for(Map.Entry<Byte,Integer> entry:counts.entrySet()){
        nodes.add(new Node(entry.getKey(),entry.getValue()));
    }

    return nodes;
}
```

- 通过这个list创建Huffman树
- 创建过程于之前的Huffman树创建过程相同
- 每次在list集合中取做小的两个节点
- 然后相加产生新的节点
- 将新节点的左右子节点指向这两个节点
- 把新节点加入list并且删除刚刚取出的两个节点
- 再排序循环创建Huffman树

**代码**

```java
// 通过List，创建对应的huffman树
private static Node createHuffmanTree(List<Node> nodes){
    Node firstNode;
    Node secNode;
    Node newNode;
    // nodes排序
    Collections.sort(nodes);
    // 只有当list中只存在一个node的时候就说明这个node是root节点也代表了huffman树创建完毕就返回
    while (nodes.size()>1){
        // 每次都取第一个和第二个节点(也就是权值最小的两个节点
        firstNode = nodes.get(0);
        secNode = nodes.get(1);
        // 合成一个新的节点权值为这两个节点之和
        newNode = new Node(null,firstNode.weight+secNode.weight);
        // 在删除旧节点之前把他们加入到huffman树中
        newNode.left = firstNode;
        newNode.right = secNode;
        // 把新节点加入list并且删除用于创建这个节点的两个节点
        nodes.add(newNode);
        nodes.remove(firstNode);
        nodes.remove(secNode);
        //再排序
        Collections.sort(nodes);

    }
    return nodes.get(0);
}
```

### 生成Huffman编码和Huffman编码后的数据

根据左子树的路径为0右子树的路径为1生成Huffman编码，借助一个StringBuilder记录遍历到真正具有数据的子节点所经过的路径作为编码准则

**代码**

```java
// 重载
private static Map<Byte,String> getCodes(Node root){
    if (root == null){
        return null;
    }
    getCodes(root,"",stringBuilder);
    return huffmanCodes;
}

/**
 *
 * 将传入就的node节点的所有叶子节点的Huffman编码得到并放入到HuffmanCode集合
 * @param node 传入节点
 * @param code 路径：左子节点0右子节点1
 * @param stringBuilder  用于拼接路径
 * 其实生成Huffman编码的时候还是类似于树的先序遍历
 *  在先序遍历是根左右，其实根就代表了要对这棵树采取的操作，
 *                       真正的遍历其实只要遍历左右子数即可完成全部节点的遍历
 *                       只不过在遍历过程中进行了一些操作从而形成了三种遍历，前序中序后序
 *                       在遍历左右子树的前中后分别做出了一些操作
 */
private static Map<Byte,String> getCodes(Node node,String code,StringBuilder stringBuilder){
    StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
    // 将code加入到stringBuilder2
    stringBuilder2.append(code);
    if (node!=null){
        // 如果node== null 补充不利
        //判断当前node是叶子节点还是非叶子节点
        if (node.data == null){
            // 非叶子节点
            // 递归处理
            // 向左
            getCodes(node.left,"0",stringBuilder2);
            // 向右递归
            getCodes(node.right,"1",stringBuilder2);
        }else {
            // 说明是一个叶子节点
            // 就表示找到了某个叶子节点的最后
            huffmanCodes.put(node.data,stringBuilder2.toString());
        }
    }
    return huffmanCodes;
}
```

根据Huffman编码进行压缩（将原始的字节数组根据Huffman编码压缩为新的字节数组）

先将原始子节数组转为经过Huffman编码的字符串

分割字符串形成压缩后的字节数组返回

**代码**

```java
/**
 *
 * @param bytes 原始数组
 * @param huffmanCodes Huffman编码表
 * @return 返回Huffman编码处理后的byte
 */
private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes){
    // 先利用Huffman编码表将byte数组转为Huffman编码对应的字符串
    StringBuilder stringBuilder = new StringBuilder();
    System.out.println("byte.length:" + bytes.length);
    // 遍历
    for (byte b:bytes){
        stringBuilder.append(huffmanCodes.get(b));
    }
    System.out.println("stringBuilder:" + stringBuilder.toString());
    // 将编码后的内容转为byte数组
    // 统计返回byte[] huffmanCodeBytes长度
    int len;
    if (stringBuilder.length() % 8 == 0){
        len = stringBuilder.length()/8;
    }else {
        len = stringBuilder.length()/8+1;
    }
    // 创建huffmanCodeBytes
    // 创建存储压缩后的byte数组
    byte[] huffmanCodeBytes = new byte[len];
    int index = 0; // 记录是第几个byte
    for (int i = 0; i < stringBuilder.length(); i+=8) {
        // 每八位对应一个byte所以步长为0
        String strByte;
        if (i+8>stringBuilder.length()){
            strByte = stringBuilder.substring(i);//从当前取值到最后
        }else {
            strByte = stringBuilder.substring(i,i+8);//[)
        }

        byte b = (byte) Integer.parseInt(strByte, 2);

        // 将strByte转为一个byte放入by
        huffmanCodeBytes[index] = b;
        index++;
    }
    return huffmanCodeBytes;
}
```

### 使用Huffman编码解码

解码其实就是编码的相反操作。

根据压缩后的字符数组与Huffman编码进行解码

遍历数组将数组重新转为由二进制构成的String字符串

**转换代码**

```java
/**
     *  将一个byte转成一个二进制的字符串
     *  就是对byte b = (byte) Integer.parseInt(strByte, 2);
     *  的反向解码
     * @param b 传入的byte
     * @param flag true:需要补高位，，上面传过来的flag如果为true代表不是最后一个字节
     * @return 是该b对应的二进制的字符串（补码返回，因为编码也是补码
     */
    private static String byteToBitString(boolean flag,byte b){
        // 使用变量保存b
        int temp = b;// 将b转为int
//        System.out.println("temp:" + temp);
        // 如果是正数我们还存在补高位
        // 其实这里也针对只有最后以为byte可能不是八位的就直接添加即可
        // 在进行Huffman编码时，八位八位的转换为byte但是除了最后一位
        // 最后一位是直接转换的不一定是八位
        if (flag){
            temp |= 256; //按位与 // temp 1 => 0000 0001 | 1 0000 0000 = 1 0000 0001
        }

        String str = Integer.toBinaryString(temp);// 返回的是temp对应的二进制补码
//        System.out.println("str:" + str);

        // str:11111111111111111111111110101000 截取后八位即为byte对应的二进制补码
        // 10101000 -1 取反 1101 1000 就是88
        // 二进制在计算机中是以补码保存的
        // 所以toBinaryString得到的是补码并且过长要截取后八位转为原码

        if (flag){
            // 如果不是最后一个字节就需要去后八位
            return str.substring(str.length()-8);
        }else {
            // 如果是最后一个字节，则直接返回即可
            return str;
        }

    }
```

将Huffman编码进行逆序形成解码表

```java
// 把字符串按照指定的Huffman编码表进行解码
// 把Huffman编码表进行调换，因为要反向查询
// 原先:a->转为二进制byte->100
// 现在:100->找对应的二进制byte->原初字符串
Map<String,Byte> map = new HashMap<>();

for (Map.Entry<Byte,String> entry : huffmanCodes.entrySet()){
    map.put(entry.getValue(),entry.getKey());
}
```

遍历整个二进制字符串根解码表进行匹配解码

完整代码如下：

```java
// 数据的解压
    // 将[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
    // 转为Huffman编码对应的二进制字符串
    // 将二进制字符串对照Huffman编码表转为原来的二进制字符串
    // 将原来的二进制字符串转为字符串
    // 转为"i like like like java do you like a java"

    /**
     *
     * @param huffmanCodes Huffman编码表
     * @param huffmanBytes Huffman编码得到的字节数组
     * @return
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes){
        // byte中存放的是字节可以按照十进制进行打印，要将这些十进制重新转为一长串字符串
        // 先得到huffmanBytes对应的二进制字符串 其实就是将-88转为10101000
        StringBuilder stringBuilder = new StringBuilder();
        // 将byte数组转为=二进制字符串
        for (int i = 0; i < huffmanBytes.length; i++) {
            // 判断是否是最后一个字节
            // 如果是最后一个字节那么就是true
            boolean flag = (i==huffmanBytes.length-1);
            byte b = huffmanBytes[i];
            // 但是这边传递的是!flag,有点反人类了
            // 说明true代表不是最后一个字节
            stringBuilder.append(byteToBitString(!flag,b));
        }
        System.out.println("huffman字节数组对应的二进制字符串：" + stringBuilder.toString());
        // 把字符串按照指定的Huffman编码表进行解码
        // 把Huffman编码表进行调换，因为要反向查询
        // 原先:a->转为二进制byte->100
        // 现在:100->找对应的二进制byte->原初字符串
        Map<String,Byte> map = new HashMap<>();

        for (Map.Entry<Byte,String> entry : huffmanCodes.entrySet()){
            map.put(entry.getValue(),entry.getKey());
        }
        System.out.println("reverse map:" + map);
        // 创建集合存放byte
        List<Byte> list = new ArrayList<>();
        StringBuilder builder = new StringBuilder();
        // 自己的想法
        // 遍历整个转换后（由字节数组转为了二进制字符串）后的二进制字符串
        // 在整个遍历过程中i不停的向后移动即可
        for (int i = 0; i < stringBuilder.length(); i++) {
            // StringBuilder用来保存单次可能在Huffman解码表中出现的字符串
            builder.append(stringBuilder.charAt(i));
            // 判断是否出现该字符串，如果第一次循环则StringBuilder中只保存了一个字符
            // 多次循环后StringBuilder中可保存了多个字符
            // 判断map中是否包含要找的字符串
            if (map.containsKey(builder.toString())){
                //如果找到则添加到list集合
                list.add(map.get(builder.toString()));
                // 将builder清空，以便下一次使用
                builder = new StringBuilder();
            }
        }

        // 官方答案
//        for (int i = 0; i < stringBuilder.length(); ) {
//            int count = 1;// 小的计数器
//            boolean flag = true;
//            Byte b = null;
//            while (flag){
//                // 取出一个‘1’/‘0’
//                // i 不动让count移动，直到匹配到一个字符
//                String key = stringBuilder.substring(i,i+count);
//                b = map.get(key);
//                if (b==null){
//                    count++;
//                }else {
//                    flag = false;
//                }
//
//            }
//            list.add(b);
//            i+=count;// i移动到count位置
//        }
        
        // 当for循环结束后list中就存放了所有的字符
        // 把list中的数据放入byte[] 并返回
        byte[] b= new byte[list.size()];
        for (int i = 0; i < b.length; i++) {
            b[i] = list.get(i);
        }

        return b;

    }
```



### 文件压缩

通过IO流和上述写的Huffman编码解码将文件进行压缩

**代码**

```java
// 将一个文件进行压缩

/**
 *
 * @param srcFile 希望压缩的文件的全路径
 * @param dstFile 压缩后将压缩文件放到哪个路径
 */
public static void zipFile(String srcFile,String dstFile){
    // 创建输出流
    // 创建一个文件的输入流
    FileInputStream is = null;
    OutputStream os = null;
    ObjectOutputStream oos = null;
    try {
        is = new FileInputStream(srcFile);
        // 创建一个和源文件大小一样的byte[]数组
        byte[] b = new byte[is.available()];
        // 读取文件
        is.read(b);
        // 直接对源文件压缩
        byte[] huffmanBytes = huffmanZip(b);
        // 创建文件的输出流，存放压缩文件
        os = new FileOutputStream(dstFile);
        // 创建一个和文件输出流关联的ObjectOutputStream
        oos = new ObjectOutputStream(os);

        /// 把Huffman编码后的字节数组写入压缩文件
        oos.writeObject(huffmanBytes); // 我们把


        // 这里我们以对象流的方式写入Huffman编码
        // 为了以后恢复源文件时使用
        // 注意一定要把Huffman编码写入压缩文件
        oos.writeObject(huffmanCodes);

    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        try {
            is.close();
            os.close();
            oos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

注意：上述代码中将压缩过的字节数组作为一个对象，将Huffman编码表作为一个对象对压缩后的文件用ObjectOutputStream进行了两次写入这样其实是为了方便解压（做相反操作，取出两个对象）以免混乱，在文件解压中回具体体现

### 文件解压

通过IO读取两个对象（就是压缩时写入的两个对象）再通过上述写过的解码代码进行解码，将解码后的子节数组写入新文件中完成解压

**代码**

```java
// 解压文件

/**
 *
 * @param zipFile 准备解压的zip文件
 * @param dstFile 将文件解压到哪个路径
 */
public static void unZipFile(String zipFile,String dstFile){
    // 定义文件的输入流
    InputStream is = null;
    // 定义一个对象输入流
    ObjectInputStream ois = null;
    // 定义文件的输出流
    OutputStream os = null;
    try {
        // 创建文件输入流
        is = new FileInputStream(zipFile);
        // 创建一个和is关联的对象输入流
        ois = new ObjectInputStream(is);
        //读取byte数组 huffmanBytes
        byte[] huffmanBytes = (byte[])ois.readObject();
        // 读取Huffman编码表
        Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();

        // 解码
        byte[] bytes = decode(huffmanCodes, huffmanBytes);

        // 将bytes写入到目标文件
        os = new FileOutputStream(dstFile);
        // 写出数据到文件中
        os.write(bytes);
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        try {
            os.close();
            ois.close();
            is.close();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

## 二叉排序树

**需求**

![1572793005771](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572793005771.png)

**简介**

二叉排序树BST（Binary Sort(Search) Tree）,对于二叉排序树的任何一个非叶子节点，要求左子节点的值小于当前节点的值，右子节点的值大于当前节点的值。

如果由相同的节点可以放在左子节点或右子节点

![1572793093956](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572793093956.png)

### 创建

首先写二叉排序树的节点在节点中添加一些新代码

创建方法将要添加的新节点进行遍历比较找到插入的位置进行创建

**代码**

```java
// 添加节点
// 递归的形式添加节点，注意需要满足二叉排序树的要求
public void add(Node node){
    if (node == null){
        return;
    }

    // 判断传入的节点的值和当前子树的根节点的关系
    if (node.value<this.value){
        // 如果左子节点为空就直接挂到左子节点即可
        // 注意要调用this.left而不是node.left
        if (this.left==null){
            this.left = node;
        }else {
            // 不为空则继续递归向左子节点添加数据直到找到一个合适的位置进行添加
            this.left.add(node);
        }
    }

    // 如果传入值大于等于根节点值其添加方式类似于 向左子节点添加
    if (node.value>=this.value){
        if (this.right==null){
            this.right = node;
        }else {
            this.right.add(node);
        }
    }
}
```

### 遍历

遍历与普通树的遍历并无不同

但需要注意的是二叉排序树BST的中序遍历输出的就是有序数组

**代码**

```java
// 中序遍历
// 中序遍历二叉排序树时，遍历的值正好是有序的
public void infixOrder(){
    if (this.left != null){
        this.left.infixOrder();
    }
    System.out.println(this);
    if (this.right!= null){
        this.right.infixOrder();
    }
}
```

### 删除

删除比较麻烦要考虑三种情况

删除叶子节点

删除只有一棵子树的节点

删除有两颗子树的节点

![1572793444655](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572793444655.png)

![1572793434394](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572793434394.png)

![1572793452571](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572793452571.png)

**代码**

第二种情况中要判断待删除结点拥有左子节点还是右子节点，待删除结点是父节点的左子节点还是右子节点

一共回产生四种情况分别解决

```java
// 返回以node为根节点的二叉排序树的最小节点的值
// 删除以node为根节点的二叉排序树的最小节点
/**
 *
 * @param node 传入的节点(二叉排序树的根节点
 * @return 返回以node为根节点的二叉排序树的最小节点的值
 */
public int delRightTreeMin(Node node){
    Node target = node;
    // 循环查找左节点
    while (target.left!=null){
        target = target.left;
    }
    // 这时target指向了最小节点
    // 删除最小节点
    delNode(target.value);
    return target.value;
}

// 删除节点
public void delNode(int value){
    if (root == null){
        return;
    }else {
        // 找要删除的targetNode
        Node targetNode = search(value);
        // 如果未找到
        if (targetNode == null){
            return;
        }
        // 如果target没有父节点（就是根节点/当前二叉排序树只有一个节点
        if (root.left == null&& root.right == null){
            root = null;
            return;
        }
        // 找父节点
        Node parentNode = searchParent(value);
        // 如果要删除的节点是叶子节点
        if (targetNode.left==null&&targetNode.right == null){
            // 判断targetNode是父节点的左子节点还是右子节点
            if (parentNode.left!=null && parentNode.left.value == value){
                parentNode.left = null;
            }else if (parentNode.right!=null && parentNode.right.value == value){
                parentNode.right = null;
            }
        }else if (targetNode.left!=null&&targetNode.right!=null){
            // 有左右子树
            // 从左边找最小的移动到待删除节点
            // 将最小节点删除
            int minval = delRightTreeMin(targetNode.right);
            targetNode.value = minval;
        }else {


            // 删除只有一棵子树的节点
            if (targetNode.left !=null){
                if (parentNode!=null){
                    // 有左子节点
                    if (parentNode.left.value == value){
                        parentNode.left = targetNode.left;
                    }else{
                        parentNode.right = targetNode.left;
                    }
                }else {
                    root = targetNode.left;
                }

            }else {
                if (parentNode!=null){
                    // 有右子节点
                    if (parentNode.left.value == value){
                        parentNode.left = targetNode.right;
                    }else{
                        parentNode.right = targetNode.right;
                    }
                }else {
                    root = targetNode.right;
                }

            }
        }

    }
}

// 查找节点
    public Node search(int value){
        if (value == this.value)
            return this;
        if (value<this.value){
            if (this.left!=null){
                return this.left.search(value);
            }else {
                return null;
            }
        }else {
            if (this.right!=null){
                return this.right.search(value);
            }else {
                return null;
            }
        }
    }

    // 查找要删除节点的父节点
    public Node searchParent(int value){
        if ((this.left!=null&&value == this.left.value) ||
                (this.right!=null&&value== this.right.value)) {
            return this;
        }else if (value<this.value && this.left!=null){
            return this.left.searchParent(value);
        }else if(value>=this.value&& this.right!=null){
            return this.right.searchParent(value);
        }
        // 没有找到父节点
        return null;

    }

```

## 平衡二叉树（AVL树）

**简介**

平衡二叉树是简历在二叉排序树的基础上的

起因：如果用{1,2,3,4,5,6}构成一颗二叉排序树，那么很显然，左子树全部为空，右子树是斜着的一条线，也就是说树退化成了链表

平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又叫AVL树，可以保证查询效率较高。

**特点**

- 它是一颗空树或他左右子树的高度差绝对不超过1
- 左右子树也是一颗平衡二叉树（是一颗空树或他左右子树的高度差绝对不超过1）

平衡二叉树的常见实现:红黑树、AVL、替罪羊树、伸展树等



**图解**

举例：

![1572964862388](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572964862388.png)

产生高度差后进行平衡的解决方案：

**左旋**

如果一颗二叉排序树的右子树高度与左子树的高度差大于2的情况下

![1572965002060](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572965002060.png)

此时需要经过向左旋转使树重新平衡

左旋思路如下：

- 创建一个新的节点
- 将新节点的左子节点指向根节点的左子树
- 将新节点的右子节点指向根节点的右子节点的左子节点
- 记录根节点的值
- 将根节点的值替换为根节点右子节点的值
- 将记录过的根节点值赋值给新建节点
- 将替换后的根节点的左子节点指向新建节点
- 将替换过的根节点的右子节点指向根节点的右子节点的右子节点

**图解**

![1572965276601](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572965276601.png)

**代码**

```java
// 左旋转
private void leftRotate(){
    // 创建新节点，以当前根节点的值
    Node newNode = new Node(value);
    // 把新的节点左子树设为当前节点的左子树
    newNode.left = left;
    // 把新的节点的右子树设置成当前节点的右子树的左子树
    newNode.right = right.left;
    // 把当前节点的值替换为右子节点的值
    value = right.value;
    // 把当前节点的右子树设置为右子树的右子树
    right = right.right;
    // 把当前节点的左子节点设置为新节点
    left = newNode;
}
```

**右旋**

如果一颗二叉排序树的左子树高度与右子树的高度差大于2的情况下

![1572965359225](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572965359225.png)

此时需要经过向右旋转使树重新平衡

右旋思路如下：

- 创建一个新的节点
- 将新节点的右子节点指向根节点的右子树
- 将新节点的左子节点指向根节点的左子节点的右子节点
- 记录根节点的值
- 将根节点的值替换为根节点左子节点的值
- 将记录过的根节点值赋值给新建节点
- 将替换后的根节点的右子节点指向新建节点
- 将替换过的根节点的左子节点指向根节点的左子节点的左子节点

**图解**

![1572965461194](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572965461194.png)

**代码**

```java
// 右旋转
private void rightRotate(){
    // 新建节点
    Node newNode = new Node(value);
    // 将当前节点的右子树设置为新节点的右子树
    newNode.right = right;
    // 将当前节点的左子树的右子树设置为新节点的左子树
    newNode.left = left.right;
    //将当前节点的左节点的值作为当前节点的值
    value = left.value;
    // 将当前节点的左子树设置为左子树的左子树
    left = left.left;
    // 当前节点的右子树设置为新节点
    right = newNode;

}
```

**双旋**

有一下问题：树如果只经过一次左旋/右旋任然不是平衡二叉树

有以下两种情况会产生这种奇怪的树

左旋根节点的左子节点的右子树的叶子节点高度比根节点的右子节点的高度高2以上，而不是根节点的左子节点的左子节点的叶子节点比根节点的右子节点的高度高2以上

右旋时候也会出现这个问题

图解

![1572965786763](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572965786763.png)

解决思路

当树要进行右旋时先判断它左子节点的右子树高度是否大于它（根节点的左子节点）的左子节点高度

若大于则先对根节点的左子节点进行左旋

再对根节点进行右旋即可

**代码**

```java
// 添加节点
    // 递归的形式添加节点，注意需要满足二叉排序树的要求
    public void add(Node node){
        if (node == null){
            return;
        }

        // 判断传入的节点的值和当前子树的根节点的关系
        if (node.value<this.value){
            // 如果左子节点为空就直接挂到左子节点即可
            // 注意要调用this.left而不是node.left
            if (this.left==null){
                this.left = node;
            }else {
                // 不为空则继续递归向左子节点添加数据直到找到一个合适的位置进行添加
                this.left.add(node);
            }
        }

        // 如果传入值大于等于根节点值其添加方式类似于 向左子节点添加
        if (node.value>=this.value){
            if (this.right==null){
                this.right = node;
            }else {
                this.right.add(node);
            }
        }

        // 当添加完一个节点后，如果右子树的高度-左子树的高度>1
        // 左旋转
        if (rightHeight()-leftHeight()>1){
            // 如果它（根节点）的右子树的左子树高度大于它（根节点的左子树）的右子树高度
            if (right!=null && right.leftHeight()>right.rightHeight()){
                // 对当前节点的右子树进行右旋转
                right.rightRotate();
                // 再对当前节点进行旋转
            }
            leftRotate();

            // 处理完之后记得return 以免出错
            return;
//            if (right!=null&&right.rightHeight()<right.leftHeight()){
//                // 先对右子树进行
//                leftRotate();
//            }
        }

        // 当添加完一个节点后，如果左子树的高度-右子树的高度>1
        // 右旋转
        if ((leftHeight()-rightHeight())>1){
            // 如果它（根节点）的左子树的右子树高度大于它（根节点的左子树）的左子树的高度
            if (left!=null && left.rightHeight()>left.leftHeight()){
                // 先对当前节点的左节点（左子树）进行左旋转
                left.leftRotate();
                // 再对当前节点进行旋转
            }
            rightRotate();

            return;
        }

    }
```

## 多路查找树

在查询时常用，比如2-3树，2-3-4树，B-树，B+树，B*树都是将树设计的尽量扁平使得查找时候减少遍历次数

具体应用：数据库索引，文件系统等，具体详见其他章节



所有关于树的完整代码都在github

<https://github.com/luoziling/Design_Pattern/tree/master/src/priv/wzb/datastructure/tree>

欢迎大家star fork