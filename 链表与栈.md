# 链表与栈

## 链表

链表是有序的列表，但它在内存中是存储如下：

![](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572361783652.png)

上图小结：

- 链表是以节点的方式来存储，是**链式存储**的
- 每个节点包含data域，next域：指向下一个节点
- 如图：发现**链表的各个节点不一定是连续存储的**
- 链表分带**头节点**的链表和**没有头节点**的链表

![1572361894806](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572361894806.png)

### 单链表的应用实例

使用带head头的单向链表实现--水浒英雄排行榜管理冠城对英雄人物的增删改查

- 第一种方法在添加英雄时直接添加到链表尾部

![1572361992203](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572361992203.png)

- 第二种方法在添加英雄时，根据排名将英雄插入指定位置（如果有这个排名则添加失败，给出提示

思路分析：

![1572362039504](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572362039504.png)

- 修改节点功能

思路

1.先找到该节点，通过遍历

2.

```java
temp.name = newHeroNode.name;
temp.nickname = newHeroNode.nickname;
```

- 删除节点

![1572362174974](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572362174974.png)

```java
package priv.wzb.datastructure.linkedlist;

import java.util.LinkedList;
import java.util.Stack;

/**
 * @author Satsuki
 * @time 2019/10/28 22:29
 * @description:
 */


public class SingleLinkedListDemo {
    public static void main(String[] args) {
        // 进行测试
        // 先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");

        HeroNode hero5 = new HeroNode(2, "小路", "玉麒麟111");

        // 创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 加入
//        singleLinkedList.add(hero1);
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
//        singleLinkedList.add(hero4);

        // 加入按照编号的顺序
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero2);

        singleLinkedList.update(hero5);
        // 显示
        singleLinkedList.list();

        // 逆序打印
        System.out.println("逆序打印");
        reversePrint(singleLinkedList.getHead());

        System.out.println("反转:");
        reverse(singleLinkedList.getHead());
        singleLinkedList.list();

        System.out.println("删除后的情况：");

        // 删除一个节点
        singleLinkedList.del(1);
//        singleLinkedList.del(2);
//        singleLinkedList.del(3);
//        singleLinkedList.del(4);
        // 显示
        singleLinkedList.list();

        // 求单链表中有效节点的个数
        System.out.println("有效的节点个数"+getLength(singleLinkedList.getHead()));

        // 测试以下看看是否得到了倒数第K个节点
//        HeroNode res = findLastIndexNode(singleLinkedList.getHead(),1);
        HeroNode res = findLastIndexNode(singleLinkedList.getHead(),4);
        System.out.println("res=" + res);



    }

    // 逆序打印单链表（百度）
    // 方式一
    // 先逆序，再打印
    // 方式二
    // 利用栈，利用栈先进后出的特点，逆序打印
    // 此处演示方式2
    public static void reversePrint(HeroNode head){
        if (head.next == null){
            return; // 空链表不打印
        }

        // 创建栈存放链表元素完成逆序打印
        Stack<HeroNode> heroNodeStack = new Stack<>();
        // 创建辅助指针
        HeroNode temp = head;
        while (temp.next!=null){
            heroNodeStack.push(temp.next);
            temp = temp.next;// 遍历
        }

        while (heroNodeStack.size()>0){
            // 打印
            System.out.println(heroNodeStack.pop());
        }
    }


    // 反转链表(腾讯)
    // 思路
    // 定义一共reverseHead = new HeroNode()
    // 从头到尾遍历原来的链表，每遍历一共节点将其取出放在reverseHead的最前端。
    // 原来链表的head.next = reverseHead.next
    public static void reverse(HeroNode head){
        // 形参检测
        // 如果当前链表为空，或者只有一个节点，直接返回。
        // 这边不仅是形参检测更加进行了算法优化
//        if (head == null || getLength(head)==1){
//            return;
//        }
        if (head == null || head.next.next==null){
            return;
        }

        // 定义一共辅助指针（变量）帮助我们遍历原来的链表
        HeroNode cur = head.next;
        HeroNode next = null; // 指向当前节点【cur】的下一个节点
        // 初始化反转节点
        HeroNode reverseHead = new HeroNode(0,"","");
        // 从头到尾遍历原来的链表，每遍历一共节点将其取出放在reverseHead的最前端。
        while (cur!=null){
            // 先暂时保存当前节点的下一个节点因为后面有用
            next = cur.next;
            //将cur的下一个节点指向新链表的头节点（最前端

            // 其实这里很像插入节点的情形
            // cur.next就是待插入的节点。
            // 待插入节点的next指向要插入位置的next
            // 这里一直是插入到第一个节点所以一直指向头节点的下一个节点（也就是第一个节点）
            // 需要先进行cur.next = reverseHead.next;是为了防止之前插入的节点丢失（不可达
            // 之后需要把头节点的下一个节点指向待插入节点即可完成插入
            cur.next = reverseHead.next;
            reverseHead.next = cur;
            cur = next; // 让cur后移

        }

        // 将head.next指向reverseHead.next,实现单链表的反转
        head.next = reverseHead.next;

    }

    // 查找单链表中的倒数第K个节点【新浪面试题】
    // 思路
    // 编写一共方法接收head节点，同时接收一个index
    // index表示是倒数第index个节点
    // 把链表从头到尾遍历，得到链表的总长度 getLength()
    // 得到size后，从链表的第一个开始遍历（size-index)个就可以得到
    public static HeroNode findLastIndexNode(HeroNode head,int index){
        // 判断如果链表为空，返回null
        if (head.next == null){
            return null;
        }

        // 第一个遍历得到链表长度（节点个数
        int size = getLength(head);
        // 第二次遍历size-index位置，就是我们要找的倒数第K个节点
        // 先做一个index的校验
        // 所有传过来的形参都需要做校验不管是判空还是超出范围
        if (index<=0 || index>size){
            return null;
        }

        // 定义辅助变量
        HeroNode cur = head.next;
        // for 循环定位到倒数的index
        for (int i = 0; i < size - index; i++) {
            cur = cur.next;
        }

        return cur;

    }



    // 方法：获取到单链表的节点个数（如果是带头节点的链表，需要不统计头节点)
    /**
     *
     * @param head 链表的头节点
     * @return 返回的就是有效节点的个数
     */
    public static int getLength(HeroNode head){
        if (head.next == null){
            // 空链表
            return 0;
        }
        int length = 0;
        // 定义一共辅助变量
        // 同一去除头节点不统计头节点
        HeroNode cur = head.next;
        while (cur !=null){
            length++;
            cur = cur.next;// 遍历
        }
        return length;
    }

}







//定义SingleLinkedList管理
class SingleLinkedList {
    // 先初始化一个头节点，头节点不动，不存放具体数据
    private HeroNode head = new HeroNode(0,"","");


    public HeroNode getHead() {
        return head;
    }

    public void setHead(HeroNode head) {
        this.head = head;
    }

    // 添加节点到单向链表
    // 当不考虑编号顺序时
    // 1.找到当前链表的最后一个节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode temp = head;

        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next == null){
                break;
            }
            // 如果没有找到最后，将temp后移
            temp = temp.next;
        }

        // 当退出while，temp就指向了链表的最后
        // 将最后这个节点的next指向新的节点
        temp.next = heroNode;
    }
    // 第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    // （如果有这个排名则添加失败并给出提示）
    public void addByOrder(HeroNode heroNode){
        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode temp = head;
        // 因为是单链表，因此我们找到的temp是位于添加位置的前一个节点
        // 单链表只能向后遍历无法向前所以不行
        boolean flag = false;// 标识添加的编号是否存在，默认false
        while (true){
            if (temp.next == null){
                // 说明temp已经在链表最后
                break;
            }

            // 如果这个no位于temp和temp的下一个节点之间
            // 因为temp一开始指向的是头节点
            // 所以使用next不会出现要插入的节点在第一个节点就无法插入的情况
            if(temp.next.no > heroNode.no){
                // 位置找到了
                break;
            }else if (temp.next.no == heroNode.no){
                // 编号存在
                flag = true;
                break;
            }
            temp = temp.next; // 后移
        }

        if (flag){
            System.out.printf("准备插入的英雄编号%d已经存在，不能加入\n",heroNode.no);
        }else {
            // 可以插入
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    // 修改节点的信息，根据no编号来修改，即no编号不能改
    // 说明
    // 1.根据newHeroNode的no来修改即可
    public void update(HeroNode newHeroNode){
        // 判断是否空
        if (head.next == null){
            System.out.println("链表为空");
            return;
        }

        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode temp = head;

        // 是否找到
        boolean flag = false;
        while (true){
            if (temp == null){
                break;// 已经遍历到最后
            }
            if (temp.no == newHeroNode.no){
                // 找到
                flag = true;
                break;
            }
            temp = temp.next;
        }

        // 根据flag判断是否找到
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.println("找不到相同节点");
        }


    }

    // 删除节点
    // 思路
    // head节点不能动，因此需要一个temp辅助节点找到待删除节点的前一个节点
    // 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较
    public void del(int no){
        HeroNode temp = head;
        boolean flag = false; // 标识要删除节点
        while (true){
            if (temp.next==null){
                // 已经找到链表最后
                break;
            }
            if (temp.next.no == no){
                //找到了待删除结点的前一个节点temp
                flag = true;
                break;
            }


            temp = temp.next;
        }

        if (flag){
            // 如果flag为真说明找到了想要删除的节点
            // 删除节点
            temp.next = temp.next.next;
        }else {
            System.out.printf("要删除的节点%d不存在",no);
        }

    }

    // 显示链表（遍历
    public void list(){
        // 判断链表是否为空
        if (head.next == null){
            System.out.println("链表为空");
            return;
        }
        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode temp = head.next;
        while (true){
            // 判断是否到链表最后
            if (temp == null){
                break;
            }
            // 输出节点信息
            System.out.println(temp);
            // 指向下一个节点
            temp = temp.next;
        }
    }
}

// 定义HeroNode,每个HeroNode 对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickName;
    public HeroNode next; // 指向下一个节点

    // 构造器

    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```



### 双向链表应用实例

双向链表的操作分析和实现

**单项链表缺点分析**

- 只能向后不能向前
- 无法实现自删除

分析:

![1572362602400](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572362602400.png)

**对上图的说明**

- 遍历

  和单链表一样，只是可以向前也可以向后

- 添加（默认添加到最后

  先找到双向链表最后一个点temp

  ```java
  temp.next = newHeroNode;
  newHeroNode.pre = temp;
  ```

- 修改

  思路和单链表一样

- 删除

  因为是双向链表，因此，我们可以实现自我删除某个节点

  直接找到要删除的这个节点例如temp

  ```java
  temp.next.pre = temp.pre;
  temp.pre.next = temp.next;
  ```

**代码实现**

```java
package priv.wzb.datastructure.linkedlist;

import java.util.LinkedList;

/**
 * @author Satsuki
 * @time 2019/10/29 20:17
 * @description:
 * Node<E> next;
 * Node<E> prev;
 * java.util.LinkedList也是由双向链表实现的
 */
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
//        LinkedList
        // 进行测试
        // 先创建节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");

        // 创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
//        doubleLinkedList.add(hero1);
//        doubleLinkedList.add(hero2);
//        doubleLinkedList.add(hero3);
//        doubleLinkedList.add(hero4);

        // 按序插入
        doubleLinkedList.addByOrder(hero2);
        doubleLinkedList.addByOrder(hero3);
        doubleLinkedList.addByOrder(hero1);
        doubleLinkedList.addByOrder(hero4);

        doubleLinkedList.list();

        // 修改
        HeroNode2 hero5 = new HeroNode2(4, "公孙胜", "入云龙");
        doubleLinkedList.update(hero5);
        System.out.println("修改后的链表情况：");
        doubleLinkedList.list();

        // 删除
        doubleLinkedList.del(3);
        System.out.println("删除后的链表情况");
        doubleLinkedList.list();



    }
}

// 创建一个双向链表的类
class DoubleLinkedList {
    // 先初始化一个头节点，头节点不要动，不存放具体的数据
    private HeroNode2 head = new HeroNode2(0,"","");

    // 返回头节点

    public HeroNode2 getHead() {
        return head;
    }

    // 第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    // （如果有这个排名则添加失败并给出提示）
    public void addByOrder(HeroNode2 heroNode){
        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode2 temp = head;
        // 因为是单链表，因此我们找到的temp是位于添加位置的前一个节点
        // 单链表只能向后遍历无法向前所以不行
        boolean flag = false;// 标识添加的编号是否存在，默认false
        while (true){
            if (temp.next == null){
                // 说明temp已经在链表最后
                break;
            }

            // 如果这个no位于temp和temp的下一个节点之间
            // 因为temp一开始指向的是头节点
            // 所以使用next不会出现要插入的节点在第一个节点就无法插入的情况
            if(temp.next.no > heroNode.no){
                // 位置找到了
                break;
            }else if (temp.next.no == heroNode.no){
                // 编号存在
                flag = true;
                break;
            }
            temp = temp.next; // 后移
        }

        if (flag){
            System.out.printf("准备插入的英雄编号%d已经存在，不能加入\n",heroNode.no);
        }else {
            // 可以插入
            // 双向链表修改
            heroNode.next = temp.next;
            temp.next = heroNode;
            temp.next.pre = heroNode;
            heroNode.pre = temp;
        }
    }

    // 删除节点
    // 思路
    // 对于双向链表，我们可以直接找到要删除的节点
    // 找到后直接删除即可
    public void del(int no){
        // 判空
        if (head.next ==null){
            // 空链表不删除
            System.out.println("链表为空，无法删除");
            return;
        }
//        HeroNode2 temp = head;
        // 将temp指向待删除的节点即可，不用指向待删除节点的前一个节点
        HeroNode2 temp = head.next;
        boolean flag = false; // 标识要删除节点
        while (true){
            if (temp==null){
                // 已经找到链表最后
                break;
            }
            if (temp.no == no){
                //找到了待删除结点的前一个节点temp
                flag = true;
                break;
            }


            temp = temp.next;
        }

        if (flag){
            // 如果flag为真说明找到了想要删除的节点
            // 删除节点
//            temp.next = temp.next.next;
            // 双向链表的删除
            // 就是使待删除的节点从双向链表中剥离
            // 具体做法如下
            temp.pre.next = temp.next;
            // 代码有问题，考虑极端情况
            // 如果是最后一个节点就不需要执行下面这句话
            // 否则会出现空指针异常
            // 如果temp.next为null
            // null.pre会出错
            if (temp.next!=null){
                temp.next.pre = temp.pre;
            }

        }else {
            System.out.printf("要删除的节点%d不存在",no);
        }

    }


    // 可以看到双向链表的节点内容修改和单向链表几乎一样
    // 只是将原来的单向链表改为了双向链表
    // 修改节点的信息，根据no编号来修改，即no编号不能改
    // 说明
    // 1.根据newHeroNode的no来修改即可
    public void update(HeroNode2 newHeroNode){
        // 判断是否空
        if (head.next == null){
            System.out.println("链表为空");
            return;
        }

        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode2 temp = head;

        // 是否找到
        boolean flag = false;
        while (true){
            if (temp == null){
                break;// 已经遍历到最后
            }
            if (temp.no == newHeroNode.no){
                // 找到
                flag = true;
                break;
            }
            temp = temp.next;
        }

        // 根据flag判断是否找到
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.println("找不到相同节点");
        }


    }


    // 添加节点到双向链表
    // 当不考虑编号顺序时
    // 1.找到当前链表的最后一个节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode2 heroNode){
        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode2 temp = head;

        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next == null){
                break;
            }
            // 如果没有找到最后，将temp后移
            temp = temp.next;
        }

//         当退出while，temp就指向了链表的最后
//        // 将最后这个节点的next指向新的节点
//        temp.next = heroNode;
        // 形成一个双向链表
        temp.next = heroNode;
        heroNode.pre = temp;
    }



    // 遍历双向链表的方法
    // 显示链表（遍历
    public void list(){
        // 判断链表是否为空
        if (head.next == null){
            System.out.println("链表为空");
            return;
        }
        // 因为head节点不能动所有用一个temp代替（辅助遍历
        HeroNode2 temp = head.next;
        while (true){
            // 判断是否到链表最后
            if (temp == null){
                break;
            }
            // 输出节点信息
            System.out.println(temp);
            // 指向下一个节点
            temp = temp.next;
        }
    }
}



// 定义HeroNode2,每个HeroNode 对象就是一个节点
class HeroNode2{
    public int no;
    public String name;
    public String nickName;
    public HeroNode2 next; // 指向下一个节点
    public HeroNode2 pre;  // 指向前一个节点


    // 构造器

    public HeroNode2(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode2{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

### 单向环形链表

具体应用场景

Josepfu（约瑟夫、约瑟夫环）问题

![1572362968642](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572362968642.png)

单向循环链表示例

![1572363020488](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572363020488.png)

思路:

![1572364108592](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364108592.png)

![1572364114203](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364114203.png)



- 先创建链表节点（id与next指针）

- 创建单向循环链表

  先保持一个指针指向第一个节点first

  初始化：创建第一个first节点它的next指向自己形成自循环

  添加功能：给链表添加n个节点，每次都创建一个新节点，然后创建一个副本指向当前循环链表的最后一个节点，此时找到插入的地点，然后将最后一个节点的next指向要插入的新建节点，然后新建节点的next指向first，这样形成了一个单向循环链表

- 遍历功能

- 出列功能

  需要传递三个形参，从第几个小孩开始数，表示数几下，最初有多少个小孩在圈内

  让小孩报数，保持一个first的引用helper辅助指针指向环形链表的最后一个节点

  小孩报数前helper和first移动到开始的小孩first代表了开始报数的小孩而helper指向first的前一个节点

  小孩开始报数（其实就是移动helper和first指定的次数）然后找到了要出圈的小孩，

  小孩出圈

  删除小孩

  将first指向要删除小孩的下一个节点

  然后

  ```java
  helper,next = first;
  ```

**代码**

```java
package priv.wzb.datastructure.linkedlist;

/**
 * @author Satsuki
 * @time 2019/10/29 20:56
 * @description:
 * 约瑟夫（Josepfu）问题
 * 单向环形链表
 */
public class Josepfu {
    public static void main(String[] args) {
        // 测试构建与遍历
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

        // 测试一把小孩出圈是否正确
        // 从第一个小孩开始数
        // 数两下出圈
        // 一共五个小孩
        // 顺序 2 4 1 5 3
        circleSingleLinkedList.countBoy(1,2,5);
        // 测试大点的
        circleSingleLinkedList.addBoy(125);
        circleSingleLinkedList.showBoy();
        circleSingleLinkedList.countBoy(1,2,125);


    }
}

// 创建一个单向环形链表
class CircleSingleLinkedList{
    // 创建一个first节点，当前没有编号
    private Boy first = new Boy(-1);

    // 添加小孩，构建成一个环形链表
    public void addBoy(int nums){
        // nums 做一个数据校验
        // 数据校验有时候不只是校验形参还要校验当前类自己的参数
        if (nums < 1){
            System.out.println("nums 的值不正确");
        }

        // 辅助指针，帮忙便利环形链表
        Boy curBoy = null;
        // 使用for创建环形链表
        for (int i = 1; i <= nums; i++) {
            // 根据编号，创建小孩节点
            Boy boy = new Boy(i);
            // 如果是第一个小孩
            if (i == 1){
                first = boy;
                first.setNext(first); // 构成环
                curBoy = first; // 让curBoy指向第一个小孩
            }else {
                // 创建下一个boy
                curBoy.setNext(boy);
                // 构成环形链表
                boy.setNext(first);
                // 辅助指针后移
                curBoy = curBoy.getNext();
            }
        }
        
    }

    // 遍历
    public void showBoy(){
        //判断链表是否为空
        if (first == null){
            System.out.println("链表为空，没有任何小孩");
            return;
        }
        // 因为first不能动，所以使用辅助指针
        Boy curBoy = first;
        while (true){
            System.out.printf("小孩的编号%d \n",curBoy.getNo());
            // 判断是否到最后
            if (curBoy.getNext()==first){
                break;
            }
            // 后移
            curBoy = curBoy.getNext();
        }
    }

    // 根据用户的输入，计算出小孩出圈的顺序

    /**
     *
     * @param startNo 表示从第几个小孩开始数数
     * @param countNum 表示数几下
     * @param nums 表示最初由多少小孩在圈中
     */
    public void countBoy(int startNo,int countNum,int nums){
        // 数据校验
        // 当链表为空（first== null
        // 当输入的开始编号小于1
        // 当开始编号大于圈内小孩个数
        // 出错返回
        if (first == null || startNo<1 || startNo > nums){
            System.out.println("参数输入有误,请重新输入");
            return;
        }

        // 创建辅助指针，帮助完成小孩出圈
        Boy helper = first;
        // 需要创建一个辅助指针，指向环形链表的最后一个节点
        while (true){
            if (helper.getNext() == first){
                // helper说明指向了最后小孩节点
                break;
            }

            helper = helper.getNext();
        }
        // 小孩报数前，先让first和helper移动k - 1 次
        // 其实helper指向了first的前一个节点
        for (int i = 0; i < startNo - 1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }

        // 当小孩报数时，让first和helper指针同时移动m-1次，然后出圈
        // 这里是一个循环操作，知道圈中只有一个节点
        while (true){
            // 检测，如果圈中只有一个节点
            if (helper == first){
                break;
            }
            // 让first和helper移动countNum -1次
            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();
            }

            // 此时first指向的节点，就是要出圈的小孩节点
            System.out.printf("小孩%d出圈\n",first.getNo());
            // 删除小孩 将first指向的小孩出圈
            // first指向下一个节点
            first = first.getNext();
            // 让待删除节点的上一个节点指向first
            // 就是让待删除的节点从循环链表中移除让它不可达
            helper.setNext(first);
        }

        System.out.println("最后留在圈中的小孩：" + first.getNo());

    }
}

// 创建一个Boy类，表示一个节点
class Boy{
    private int no; // 编号
    private Boy next; // 指向下一个节点，默认null

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```



## 栈

实际需求

输入一个字符串表达式求解

![1572364190759](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364190759.png)

### **介绍**

- 栈的因为是stack
- 栈是一个先入后出（FILO- First In Last Out）的有序列表。
- 栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。运行插入插入和删除的一段，为**变化的一段，称为栈顶**（Top），**另一端为固定的一段称为栈底**（Bottom）
- 根据栈的定义可知最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

图解

![1572364397896](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364397896.png)

### 应用场景

- 子程序调用

  在跳往子程序前，会先将下个置零的地址存储到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。

- 处理递归调用

  和子程序的调用类似，除了存储下一个指令地址外，也将参数，区域变量等参数存储到栈中

- 表达式转换

  中缀表达式转后缀表达式与求值（实际解决）

- 二叉树遍历

- 图形的深度优先（depth-first）搜索法

思路

![1572364612509](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364612509.png)

代码

```java
package priv.wzb.datastructure.stack;

import java.util.Scanner;

/**
 * @author Satsuki
 * @time 2019/10/29 21:41
 * @description:
 */
public class ArrayStackDemo {
    public static void main(String[] args) {
        // 测试一下ArrayStack 是否正确
        // 先创建一个ArrayStack对象->表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true; // 控制是否推出菜单
        Scanner scanner = new Scanner(System.in);

//        stack.push(10);
//        stack.push(20);
//        stack.push(30);
//        stack.push(40);
//        System.out.println("maxSize:"+stack.getMaxSize());
//        System.out.println("top:"+stack.getTop());
//        System.out.println("pop:"+stack.pop());
//        System.out.println("pop:"+stack.pop());
//        System.out.println("pop:"+stack.pop());
//        System.out.println("pop:"+stack.pop());
//        System.out.println("pop:"+stack.pop());
//        loop = false;

        while (loop){
            System.out.println("s: 表示显示栈");
            System.out.println("e: 退出程序");
            System.out.println("push: 表示添加数据到栈（入栈）");
            System.out.println("pop: 表示从栈取数据（出栈）");
            System.out.println("请输入你的选择：");
            key = scanner.next();
            switch (key){
                case "s":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个值");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是%d\n",res);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    break;
                case "e":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出了");
    }
}

// 定义一个ArrayStack 表示栈
class ArrayStack{
    private int maxSize; // 栈的大小
    private int[] stack; // 数组，数组模拟栈，数据就放在该数组中
    private int top = -1; //top表设计栈顶，初始化为-1

    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    // 栈满
    public boolean isFull(){
        return top == maxSize-1;
    }

    // 栈空
    public boolean isEmpty(){
        return top == -1;
    }

    //入栈-push
    public void push(int value){
        // 先判断是否栈满
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈,将栈顶数据返回
    public int pop(){
        // 判断栈是否为空
        if (isEmpty()){
            // 抛出异常
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top-- ;
        return value;
    }

    // 遍历显示
    public void list(){
        // 遍历时需要从栈顶开始显示数据
        if (isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        System.out.println("top:" + top);
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }

    public int getMaxSize() {
        return maxSize;
    }

    public int[] getStack() {
        return stack;
    }

    public int getTop() {
        return top;
    }
}
```

### 栈实现综合计算器（中缀表达式）

![1572364703020](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364703020.png)

![1572364711110](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572364711110.png)

- 需要两个栈：数字栈和符号栈

- 解析字符串

- 如果遇到数字直接放入数字栈

- 如果遇到符号需要进行分析

  如果符号栈为空则直接放入符号栈

  如果符号栈有符号那么就要进行判断：判断当前要插入的符号与符号栈栈顶的符号哪个优先级更高，如果要插入的符号优先级小于或等于栈顶符号则弹出栈顶符号和两个数字栈的数字进行运算，注意数字栈弹出数字的顺序如果是减法或者触发需要第二个数字除以/减去第一个数字然后将运算结果入数字栈如果当前的优先级大于符号栈栈顶元素则直接入栈即可

- 当表达式扫描完毕，就顺序从数字栈和符号栈中pop相应的数字和符号（一次出栈两个数字和一个符号运算）并运算

- 最后在数字栈只有一个数字就是表达式结果

代码：

```java
package priv.wzb.datastructure.stack;

/**
 * @author Satsuki
 * @time 2019/10/29 22:18
 * @description:
 * 表达式运算
 */
public class Calculator {
    public static void main(String[] args) {
        // 根据前面的思路，完成表达式的运算
//        String expression = "3+2*6-2";
        String expression = "70+20*6-4";
        // 创建两个栈，树栈，一个符号栈
        ArrayStac2 numStack = new ArrayStac2(10);
        ArrayStac2 operStack = new ArrayStac2(10);
        // 定义需要的相关变量
        int index = 0; // 用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' '; //将每次扫描得到的char保存到ch
        String keepNumber = "";
        // 开始while循环的扫描expression
        while (true){
            //依次得到expression的每一个字符
            ch = expression.substring(index,index+1).charAt(0);
            // 判断ch是什么，然后做相应的处理
            if (operStack.isOper(ch)){
                // 如果是运算符
                // 判断当前的符号栈是否为空
                if (!operStack.isEmpty()){

                    // 如果不为空
                    // 如果符号栈有操作符，就进行比较，如果当前的操作符优先级小于等于栈中的操作符，就需要pop两个数
                    // 再从符号栈中pop一个符号，进行运算，将得到的结果入数栈，然后将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1,num2,oper);
                        // 把运算结果入数栈
                        numStack.push(res);
                        //然后把当前操作符入符号栈
                        operStack.push(ch);
                    }else {
                        // 如果当前的操作符优先级大于栈中的操作符，就直接入符号栈
                        operStack.push(ch);// 1 + 3
                    }
                }else {
                    //如果为空直接入符号栈
                    // 如果为空直接入栈。。
                    operStack.push(ch);
                }
            }else {
                // 如果是数，则直接入数栈
                //1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
                //2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈
                //3. 因此我们需要定义一个变量 字符串，用于拼接

                // 处理多位数
                keepNumber += ch;

                // 如果ch已经是expression的最后一位就直接入栈
                if (index == expression.length()-1){
                    numStack.push(Integer.parseInt(keepNumber));
                }else {
                    // 判断下一个字符是不是数字，如果是数字就继续扫描，如果是运算符，则入栈
                    // 注意是看后一位，不是index++
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                        // 如果后一位是运算符，则入栈
                        numStack.push(Integer.parseInt(keepNumber));
                        // 重要的！！！！！！！keepNumber清空
                        keepNumber = "";
                    }
                }


//                numStack.push(ch-48);
//                numStack.push(ch-'0');
            }
            // 让index+1,并判断是否扫描到expression最后
            index ++;
            if (index >= expression.length()){
                break;
            }
        }
        // 当表达式扫描完毕，就顺序从数栈和符号栈中pop出相应的数和符号，并运行
        while (true){
            // 如果符号栈为空，则计算到最后结果，数栈中只有一个数字（结果）
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1,num2,oper);
            numStack.push(res);
        }

        int res2 = numStack.pop();
        System.out.printf("表达式%s = %d",expression,res2);
    }
}

// 定义一个ArrayStack 表示栈
class ArrayStac2{
    private int maxSize; // 栈的大小
    private int[] stack; // 数组，数组模拟栈，数据就放在该数组中
    private int top = -1; //top表设计栈顶，初始化为-1

    //构造器
    public ArrayStac2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    // 增加一个方法，可以返回当前栈顶的值，但是不是真正的pop
    public int peek(){
        return stack[top];
    }

    // 栈满
    public boolean isFull(){
        return top == maxSize-1;
    }

    // 栈空
    public boolean isEmpty(){
        return top == -1;
    }

    //入栈-push
    public void push(int value){
        // 先判断是否栈满
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    //出栈,将栈顶数据返回
    public int pop(){
        // 判断栈是否为空
        if (isEmpty()){
            // 抛出异常
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top-- ;
        return value;
    }

    // 遍历显示
    public void list(){
        // 遍历时需要从栈顶开始显示数据
        if (isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        System.out.println("top:" + top);
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }

    // 返回运算符的优先级，优先级是程序员来确定的。
    // 优先级使用数字表示，数字越大，优先级越高。
    public int priority(int oper){
        if (oper == '*' || oper == '/'){
            return 1;
        }else if (oper == '+' || oper == '-'){
            return 0;
        }else {
            return -1; // 假定目前的表达式只有加减乘除，连小括号都没有
        }
    }

    //判断是不是一个运算符
    public boolean isOper(char val){
        return val == '+' || val == '-' || val == '*' || val == '/' ;
    }

    // oper存入符号栈之后因为栈用的是int数组存储所以char类型的符号会根据ASCII码转为int
    // 所以这样判断不会出错
    // 计算方法
    public int cal(int num1,int num2,int oper){
        int res = 0; // res用于存放运算结果
        switch (oper){
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2/num1;
                break;
        }
        return res;
    }

    public int getMaxSize() {
        return maxSize;
    }

    public int[] getStack() {
        return stack;
    }

    public int getTop() {
        return top;
    }
}
```

### 逆波兰计算器（后缀计算

![1572430696575](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572430696575.png)

**这里的后缀计算从数字栈中取值计算的时候总是栈的次顶元素/*-+栈顶元素**

### 中缀表达式转后缀表达式

1. 初始化两个栈，运算符栈s1和存储中间结果的栈s2

2. 从左至右扫描中缀表达式

3. 遇到操作数就压入s2

4. 遇到运算符时，比较其于s1栈顶运算符的优先级

   如果s1为空或栈顶运算符为“（”则直接将此运算符入栈

   否则，若优先级比栈顶运算符高，也将运算符压入s1

   否则（栈顶运算符不为空或者不为“（”且优先级比要压栈的运算符优先级小于等于），将s1栈顶的运算符弹出并压入s2中，再次匹配下一个栈顶运算符（跳到步骤4）。

5. 遇到括号

   如果是左括号"("，则直接压入s1

   如果是右括号“)”,则依次弹出s1栈顶的运算符，并压入s2直至遇到左括号为止，此时丢弃一对括号

6. 重复2-5步骤，直到表达式的最右边

7. 将s1中剩余的运算符依次弹出并压入s2

8. 依次弹出s2中的元素输出，结果的逆序则为中缀表达式对应的后缀表达式（其实在java中如果用ArrayList作为s2存储数据那么本身就是正序的就不必进行这一步操作

**操作示例**

![1572431526921](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1572431526921.png)

**综合代码**

```java
package priv.wzb.datastructure.stack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;
import java.util.stream.Stream;

/**
 * @author Satsuki
 * @time 2019/10/30 13:44
 * @description:
 * 中缀表达式转后缀表达式（逆波兰表达式）
 * 然后运算
 */
public class PolandNotation {
    public static void main(String[] args) {
        // 完成将一个中缀表达式转后缀表达式
        // 中缀表达式 1 + ( ( 2 + 3 )× 4) - 5 =》 后缀表达式
        // 将 s2 出栈  - 5 + * 4 + 3 2 1  =>  1 2 3 + 4 * + 5 -
        // 因为直接对str操作不方便，因此先将运算式转为中缀表达式对应的list
        // 将得到的中缀表达式对应的list转为后缀表达式对应的list

        String expression = "1+((2+3)*4)-5";
        List<String> list = toInFixExpressionList(expression);
        System.out.println("中缀表达式："+list);
        List<String> suffixExpressionList = parseSuffixExpressionList(list);

        // 后缀表达式：[1, 2, 3, +, 4, *, +, 5, -]
        System.out.println("后缀表达式：" + suffixExpressionList);

        System.out.printf("expression=%d",calculate(suffixExpressionList));




        /*

        // 先定义一个逆波兰表达式
        // (3+4)*5-6 => 3 4 + 5 * 6 -
        // 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
        // 为了方便，逆波兰表达式的数字和符号用空格隔开
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";
        // 思路
        // 先将suffixExpression放到ArrayList
        // 将ArrayList 传递给一个方法，配合栈完成计算
        List<String> list = getListString(suffixExpression);
        for (String s:list){
            System.out.println(s);
        }

        System.out.println("list:" + list);

        int res = calculate(list);
        System.out.println("res:" + res);

        */


    }

    // 方法：将得到的中缀表达式对应的list转为后缀表达式对应的list
    /**
     * 前缀 prefix
     * 中缀 infix
     * 后缀 suffix
     */
    public static List<String> parseSuffixExpressionList(List<String> ls){
        // 定义两个栈
        Stack<String> s1 = new Stack<>();// 符号栈
        // 因为S2这个栈在整个过程中没有pop操作
        // 并且还要逆序输出太过麻烦
        // 使用ArrayList
//        Stack<String> s2 = new Stack<>();// 符号栈
        List<String> s2 = new ArrayList<>(); // 存储中间结果

        // 遍历 ls
        for (String item: ls){
            // 如果是一个数，加入s2
            if (item.matches("\\d+")){
                s2.add(item);
            }else if (item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，
                // 直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop(); // !!! 将‘（’弹出s1栈
            }else {
                // 当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，
                // 再次转到(4.1)与s1中新的栈顶运算符相比较；
                // 我们缺少一个比较优先级高低的方法
                while (s1.size()!=0&& Operation.getValue(s1.peek())>=Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                // 还需要将item压入栈
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出并压入s2
        while (s1.size()!=0){
            s2.add(s1.pop());
        }

        // 因为存放到list中所以正常按序输出就是后缀表达式对应的list
        return s2;

    }

    // 将一个逆波兰表达式，依次将数据和运算符放到ArrayList中
    public static List<String> getListString (String suffixExpression){
        String[] split = suffixExpression.split(" ");
//        Stream<String> stream = Arrays.stream(split);
        List<String> list = Arrays.asList(split);
        return list;

    }

    // 方法:将中缀表达式转为对应的List
    public static List<String> toInFixExpressionList(String s){
        // 定义一个list存放中缀表达式的内容
        List<String> ls = new ArrayList<>();
        int i = 0;// 这是一个指针用于遍历中缀表达式字符串
        String str;// 对多位数的拼接
        char c; // 每遍历一个字符，就放入到C
        do {
            // 如果c是一个非数字 '0'=>48 '9'=>57
            if ((c=s.charAt(i))<'0'|| (c=s.charAt(i))>'9'){
                ls.add(""+c);
                i++; // i需要后移
            }else {
                //如果是一个数就需要考虑多位数
                str = ""; // 先将str置为""
                while (i<s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i))<=57){
                    str +=c;// 拼接
                    i++;
                }
                ls.add(str);
            }
        }while (i < s.length());

        return ls;
    }

    // 完成对逆波兰表达式的运算
    /**
     * 从左至右扫描，将3和4压入堆栈；
     * 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
     * 将5入栈；
     * 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
     * 将6入栈；
     * 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int calculate(List<String> ls){
        // 创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<>();
        // 遍历 ls
        for (String item : ls){
            //\d
            //
            //数字字符匹配。等效于 [0-9]。
            // 在java中 \\等于一个斜杠\
            // 使用正则表达式取数
            if (item.matches("\\d+")){// 匹配的是多位数
                // 入栈
                stack.push(item);
            }else {
                //pop出两个数，并运算
                // 都是后面取出的数去+-*/前面取出的数
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1+num2;
                }else if(item.equals("-")){
                    res = num1-num2;
                }else if(item.equals("*")){
                    res = num1*num2;
                }else if(item.equals("/")){
                    res = num1/num2;
                }else {
                    throw new RuntimeException("运算符有误");
                }
                // 把res 入栈
                stack.push(res + "");
            }
        }
        // 最后留在stack中的数据就是运算结果
        return Integer.parseInt(stack.pop());
    }

}

// 编写一个类Operation 可以返回一个运算符对应的优先级
class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    // 写一个方法，返回对应的优先级数字
    public static int getValue(String operation){
        int res = 0;
        switch (operation){
            case "+":
                res = ADD;
                break;
            case "-":
                res = SUB;
                break;
            case "*":
                res = MUL;
                break;
            case "/":
                res = DIV;
                break;
            default:
                System.out.println("不存在该运算符");
                break;
        }

        return res;
    }
}
```